ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

[IMPORTANT]
.Still in Early Development
====
This tool is still *very early in development*. Breaking changes are made all the time, documentation is sparse, insufficient code coverage, hard to use, poor distribution options, no license, etc. _Do not use yet._
====

= TypedConfig

**TypedConfig** is a JVM tool and library written in Kotlin to get you _actual typesafety_ when adding configuration to your application or library.

What this means is that, for example, when reading the port number for your application to start up on, you don't need to parse it from a string, or call some kind of `getInt("port")`-type method (which does all kinds of parsing and casts for you), but rather you can just call `MyConfig.port`. This still does some parsing for you -- it has to -- but as a consumer of that configuration you get things like autocomplete and config documentation (if provided) for free.

You accomplish this by writing out a spec in a `config.tc.toml` file which might look something like this:

[source,toml]
----
[port] # <1>
type = "int" # <2>
default = 8080 # <3>
constraints = ["validport"] # <4>
----

This fragment does four things:

<1> Defines a new key called `port`, which corresponds to a new property in the generated Config class. Keys are expected in lower camelcase, e.g. `applicationPort`.
<2> It's of type `int` (integer). Required.
<3> It has a default value that will be used if a value isn't found in any configuration sources. Optional.
<4> It has one constraint -- it must be a valid port. Optional.

This causes the following source code to be generated (edited for clarity):

[source,kotlin]
----
class GeneratedConfig(source: Source) {
    val port: Int by IntKey("port", source, 8080, listOf(ValidPortConstraint))
    companion object Factory {
        fun default() = GeneratedConfig(TypedConfig.defaultSource)
    }
}
----

Which you can then access in your own code:

[source,kotlin]
----
val config = GeneratedConfig.default()
val port = config.port
----

== Goals

Provide typesafe access to configuration:: When accessing configuration values, you know definitively what type it is, what the default value is, whether it's required, and what other related configuration is available. Also, hand-written documentation may also be available (if provided, obviously).
Provide configuration from multiple sources:: Look up your configuration from environment variables, static files, network services, or any combination. Specify your configuration in a file but override it using an environment variable. Specify your configuration in _multiple files_ (say, one for each deployment stage and one for defaults), and override your defaults using deployment stage-specific config.
Fail fast as early as possible:: If configuration is missing or incorrect, how quickly can we detect it and fail? TypedConfig provides constraints and validation (pending https://github.com/nanodeath/TypedConfig/issues/36[#36]) for this.
Good for both applications and libraries:: Making TypedConfig accessible to applications is easy: they control the config spec, config values, and runtime. Things are a little trickier for libraries because they have a runtime component, but don't necessarily want to telegraph the internals of their configuration library!

== Usage

Firstly, to set your expectations correctly: what this tool does a little bit tricky, and some of that trickiness leaks into the usage. It takes your configuration, turns it into source code, and then _your_ code can compile against it. That is, your code won't be able to rely on the generated source code until after it's generated! Obviously. Probably one reason why this isn't commonplace.

=== Automatically, using a Gradle plugin

TODO, no plugin yet, pending link:https://github.com/nanodeath/TypedConfig/issues/21[#21].

=== Manually

The compile workflow is basically this:

* Process config spec into generated code.
* Compile the rest of the application.

For Gradle, the one-time setup is this:

* Create a custom source set for the TypedConfig generator and add the generator to it.
* Add the TypeConfig runtime to application's `implementation` dependencies.
* Register a https://docs.gradle.org/7.4/dsl/org.gradle.api.tasks.JavaExec.html[JavaExec]-type task that executes it, and provide a path to your config and your output directory.
* Add that directory to your Gradle Java source set (even if you write Kotlin).
* Optionally, tell IntelliJ that it's a _generated_ sources directory with help from the https://docs.gradle.org/current/userguide/idea_plugin.html[idea] plugin.

Gradle plugin would simplify this substantially, no doubt.

A sample setup will be provided once https://github.com/nanodeath/TypedConfig/issues/35[#35] is completed.

== In your code

Once the configuration class has been generated and it's in your source set, you just need to construct the generated class and query its properties like normal.

If your generated config is called `GeneratedConfig`, this looks like this:

[source,kotlin]
----
val config = GeneratedConfig.default()
val port = config.port
----

Or if you want to specify a custom source for your configuration, like this:

[source,kotlin]
----
val config = GeneratedConfig.default(EnvSource())
val port = config.port
----

If you're using libraries that are using TypedConfig, and you want to change their configuration sources, you can write this:

[source,kotlin]
----
TypedConfig.defaultSource = EnvSource()
----

This works if 1. you call it _before_ the upstream library has constructed its configuration, and 2. that library is using the `default()` factory method for its own configuration (or is directly referring to `TypedConfig.defaultSource`).


== Configuration Sources

// This should be moved out to the wiki, probably -- it's not really homepage-relevant.

Configuration sources provide the actual values at runtime. For example, one of the sources is `EnvSource`, which looks
up configuration in environment variables. This may require translating the key -- if you query `EnvSource` using the
key `port`, it'll check the `PORT` environment variable, for instance.

You can choose to provide these sources either to each config object as you construct them or globally, as a default (on [TypedConfig]).

=== Built-in Sources

There are a number of built-in sources that you can use to provide configuration.

==== link:runtime/src/main/kotlin/com/github/nanodeath/typedconfig/runtime/source/EnvSource.kt[EnvSource]

EnvSource reads environment variables to populate configuration.

Keys are translated from lower camel case to screaming snake case when checking in the environment.

|===
|Config Key |Environment Variable

|`port`|`PORT`
|`applicationPort`|`APPLICATION_PORT`
|===

==== link:runtime/src/main/kotlin/com/github/nanodeath/typedconfig/runtime/source/MapSource.kt[MapSource]

MapSource simply takes a `Map<String, Any>` as a constructor argument that you provide when constructing the source. The map can be hardcoded or built any way you like.

By default, keys are passed through as is -- the key `applicationPort` is queried directly against the map as `applicationPort`.

==== link:runtime/src/main/kotlin/com/github/nanodeath/typedconfig/runtime/source/MultiSource.kt[MultiSource]

MultiSource is a higher-order source that takes a list of other sources as an input. When querying the MultiSource, it simply queries each source provided until one provides a non-null value.

If one constructs a MultiSource like this:

[source,kotlin]
----
val source = MultiSource(source1, source2)
val config = GeneratedConfig(source)
val port = config.port
----

Then MultiSource will query `source1` for the configuration, and if none is found, query `source2`, and so on, if there are more sources.

If this behavior isn't to your needs, you can also implement your own link:runtime-interfaces/src/main/kotlin/com/github/nanodeath/typedconfig/runtime/source/Source.kt[Source].

==== link:runtime/src/main/kotlin/com/github/nanodeath/typedconfig/runtime/source/CachedSource.kt[CachedSource]

CachedSource is another higher-order source that wraps another, presumably slow, source, by calling through to the delegated source and saving its results internally.

It also defines a `.cached()` extension method on Sources for convenience.

Usage is like this:

[source,kotlin]
----
val source: Source = MySlowSource().cached()
----

However, none of the built-in sources are slow enough to benefit from caching, so this is provided mainly for user-provided sources that perhaps pull configuration from the network.
